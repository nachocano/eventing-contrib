/*
Copyright 2019 The Knative Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package eventtype

import (
	"context"
	"fmt"
	"k8s.io/client-go/tools/record"

	eventingv1alpha1 "github.com/knative/eventing/pkg/apis/eventing/v1alpha1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1beta1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/util/validation"
	"regexp"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"strings"
)

// Helper functions to avoid code duplication between crd and namespace controller.
// TODO might need to come up with a better name.

const (
	// Label to get namespaces with knative-eventing enabled.
	KnativeEventingLabelKey   = "knative-eventing-injection"
	KnativeEventingLabelValue = "enabled"

	// Label to get eventing sources.
	EventingSourceLabelKey   = "eventing.knative.dev/source"
	EventingSourceLabelValue = "true"

	// Label to get the event types generated by a particular object.
	eventingEventTypeLabelKey = "eventing.knative.dev/eventtype"

	EventTypesCreated      = "EventTypesCreated"
	EventTypesCreateFailed = "EventTypesCreateFailed"
)

var (
	// Only allow alphanumeric, '-' or '.'.
	validChars = regexp.MustCompile(`[^-\.a-z0-9]+`)

	// TODO make these constants and accessible from different places (e.g., adaptors)
	// This is needed because these sources do not explicitly define the eventTypes they
	// can produce in their CRDs. We may need to try to "standarize" CRDs specs for sources.
	// Question: Why are we changing the eventType for some but not all sources?
	// E.g., for github we do, but for gcp we don't. Even more, for AWS SQS we change it but
	// differently than how we do it in github.
	eventTypeFromCrd = map[string]string{
		"awssqssources.sources.eventing.knative.dev":          "aws.sqs.message",
		"cronjobsources.sources.eventing.knative.dev":         "dev.knative.cronjob.event",
		"kuberneteseventsources.sources.eventing.knative.dev": "dev.knative.k8s.event",
		// Can be another eventType in GCPPubSub?
		"gcppubsubsources.sources.eventing.knative.dev": "google.pubsub.topic.publish",
		// What about container sources eventTypes?
		"containersources.sources.eventing.knative.dev": "dev.knative.container.event",
	}
)

func ReconcileEventTypes(client client.Client, recorder record.EventRecorder, ctx context.Context, crd *v1beta1.CustomResourceDefinition, namespace corev1.Namespace) error {
	current, err := GetEventTypes(client, ctx, crd, namespace)
	if err != nil {
		return err
	}
	expected := newEventTypes(crd, namespace)
	diff := difference(current, expected)
	if len(diff) > 0 {
		// TODO bulk creation, need to +genclient the EventList struct?
		for _, eventType := range diff {
			err = client.Create(ctx, &eventType)
			if err != nil {
				recorder.Eventf(crd, corev1.EventTypeWarning, EventTypesCreateFailed, "Could not create event type %q for namespace %q", eventType.Spec.Type, namespace.Name)
				return err
			}
		}
		recorder.Eventf(crd, corev1.EventTypeNormal, EventTypesCreated, "Event types created for namespace %q, total %d", namespace.Name, len(diff))
	}
	return nil
}

func GetEventTypes(c client.Client, ctx context.Context, crd *v1beta1.CustomResourceDefinition, namespace corev1.Namespace) ([]eventingv1alpha1.EventType, error) {
	eventTypes := make([]eventingv1alpha1.EventType, 0)

	opts := &client.ListOptions{
		Namespace:     namespace.Name,
		LabelSelector: labels.SelectorFromSet(EventTypesLabels(crd.Name)),
		// Set Raw because if we need to get more than one page, then we will put the continue token
		// into opts.Raw.Continue.
		Raw: &metav1.ListOptions{},
	}
	for {
		el := &eventingv1alpha1.EventTypeList{}
		if err := c.List(ctx, opts, el); err != nil {
			return nil, err
		}

		for _, e := range el.Items {
			eventTypes = append(eventTypes, e)
		}
		if el.Continue != "" {
			opts.Raw.Continue = el.Continue
		} else {
			return eventTypes, nil
		}
	}
}

func EventTypesLabels(objName string) map[string]string {
	return map[string]string{
		eventingEventTypeLabelKey: objName,
	}
}

func newEventTypes(crd *v1beta1.CustomResourceDefinition, namespace corev1.Namespace) []eventingv1alpha1.EventType {
	eventTypes := make([]eventingv1alpha1.EventType, 0)
	if crd.Spec.Validation != nil && crd.Spec.Validation.OpenAPIV3Schema != nil {
		properties := crd.Spec.Validation.OpenAPIV3Schema.Properties
		if spec, ok := properties["spec"]; ok {
			if eTypes, ok := spec.Properties["eventTypes"]; ok {
				if eTypes.Items != nil && eTypes.Items.Schema != nil {
					for _, eType := range eTypes.Items.Schema.Enum {
						// Remove quotes.
						et := strings.Trim(string(eType.Raw), `"`)
						eventType := makeEventType(crd, namespace, et)
						eventTypes = append(eventTypes, eventType)
					}
				}
			} else {
				// This ugly hack is just for sources that do not specify the eventTypes they can produce.
				// We should probably try to "standarize" CRD spec fields across sources.
				// At least to say what eventTypes they can produce.
				if et, ok := eventTypeFromCrd[crd.Name]; ok {
					eventType := makeEventType(crd, namespace, et)
					eventTypes = append(eventTypes, eventType)
				}
			}
		}
	}
	return eventTypes
}

func makeEventType(crd *v1beta1.CustomResourceDefinition, namespace corev1.Namespace, eventType string) eventingv1alpha1.EventType {
	return eventingv1alpha1.EventType{
		ObjectMeta: metav1.ObjectMeta{
			GenerateName: fmt.Sprintf("%s-", toValidIdentifier(eventType)),
			Labels:       EventTypesLabels(crd.Name),
			Namespace:    namespace.Name,
		},
		Spec: eventingv1alpha1.EventTypeSpec{
			Type: eventType,
			From: strings.ToLower(crd.Spec.Names.Kind),
			// TODO schema in the CRD?
			Schema: "",
		},
	}
}

func difference(current []eventingv1alpha1.EventType, expected []eventingv1alpha1.EventType) []eventingv1alpha1.EventType {
	// TODO make a more efficient implementation (O(n) instead of O(n^2))
	difference := make([]eventingv1alpha1.EventType, 0)
	for _, e := range expected {
		found := false
		for _, c := range current {
			if e.Spec.Type == c.Spec.Type &&
				e.Spec.From == c.Spec.From &&
				e.Spec.Schema == c.Spec.Schema {
				found = true
				break
			}
		}
		if !found {
			difference = append(difference, e)
		}
	}
	return difference
}

func toValidIdentifier(eventType string) string {
	if msgs := validation.IsDNS1123Subdomain(eventType); len(msgs) != 0 {
		// If it is not a valid DNS1123 name, make it a valid one.
		// TODO take care of size < 63, and starting and end indexes should be alphanumeric.
		eventType = strings.ToLower(eventType)
		eventType = validChars.ReplaceAllString(eventType, "")
	}
	return eventType
}
